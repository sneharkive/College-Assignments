# Chapter 5: Basic Computer Organization and Design

This chapter introduces the basic structure of a computer system, including instruction formats, the organization of components, control mechanisms, and how instructions are executed step by step. It sets the foundation for understanding how a computer works at the hardware level.

---

## **5.1 Instruction Codes**

### **What is an Instruction Code?**
- An **instruction code** is a group of bits that specifies a sequence of microoperations to be executed by the CPU.
- It is part of the **stored program concept**, where instructions are stored in memory and executed sequentially.

### **Structure of an Instruction Code**
- **Operation Code (Opcode)**:
  - Specifies the operation to be performed, such as `ADD`, `LOAD`, or `STORE`.
  - For example, a 3-bit opcode can define up to \( 2^3 = 8 \) unique operations.
- **Address Field**:
  - Specifies the address of the operand in memory.
  - Can also specify a register or an immediate value depending on the addressing mode.

### **Addressing Modes**
1. **Direct Addressing**:
   - The address field contains the actual memory location of the operand.
   - Example:
     - Instruction: `LOAD 2000`.
     - Action: AC ← Memory[2000].
2. **Indirect Addressing**:
   - The address field contains a pointer to the memory location of the operand.
   - Example:
     - Instruction: `LOAD @2000`.
     - Action: AC ← Memory[Memory[2000]].
3. **Register Addressing**:
   - The operand is located in a CPU register.
   - Example:
     - Instruction: `ADD R1`.
     - Action: AC ← AC + R1.

---

## **5.2 Computer Registers**

Registers are high-speed storage locations inside the CPU that temporarily hold data and instructions. They are essential for processing and communication within the CPU.

### **Types of Registers**
1. **Memory Address Register (MAR)**:
   - Holds the memory address of the data or instruction to be accessed.
   - Example: `MAR ← PC` (Load the address of the next instruction into MAR).

2. **Memory Data Register (MDR)**:
   - Temporarily holds the data being read from or written to memory.
   - Example: `MDR ← Memory[MAR]` (Fetch the instruction at the address in MAR).

3. **Program Counter (PC)**:
   - Contains the address of the next instruction to be executed.
   - Automatically increments after each instruction fetch.
   - Example: `PC ← PC + 1`.

4. **Instruction Register (IR)**:
   - Holds the current instruction being decoded and executed.
   - Example: After fetching, `IR ← MDR`.

5. **Accumulator (AC)**:
   - A primary register for arithmetic and logic operations.
   - Example: For `ADD X`, `AC ← AC + Memory[X]`.

6. **Temporary Register (TR)**:
   - Stores intermediate results during processing.
   - Example: TR is used to temporarily store the result of a computation before transferring it to AC.

### **Data Flow**:
Registers communicate with memory and ALU through buses under control signals:
- **Control Bus**: Sends control signals to activate specific registers.
- **Data Bus**: Carries data to/from registers.
- **Address Bus**: Carries addresses for memory or I/O operations.

- ![List of Registers](./Register.png)

---

## **5.3 Computer Instructions**

Computer instructions specify operations for the CPU to perform and where to find the operands.

### **Instruction Set Classification**
1. **Data Transfer Instructions**:
   - Move data between memory, registers, and I/O.
   - Examples:
     - `LOAD X`: Load the contents of memory location `X` into AC.
     - `STORE X`: Store the contents of AC into memory location `X`.

2. **Arithmetic Instructions**:
   - Perform arithmetic operations such as addition, subtraction, multiplication, and division.
   - Examples:
     - `ADD X`: Add the contents of memory location `X` to AC.
     - `SUB X`: Subtract the contents of memory location `X` from AC.

3. **Logical Instructions**:
   - Perform logical operations such as AND, OR, NOT, and XOR.
   - Examples:
     - `AND X`: Perform bitwise AND between AC and `X`.
     - `OR X`: Perform bitwise OR operation.

4. **Control Instructions**:
   - Change the sequence of execution.
   - Examples:
     - `JUMP X`: Jump to instruction at memory location `X`.
     - `CALL X`: Call a subroutine at memory location `X`.
     - `RETURN`: Return from a subroutine.

---

## **5.4 Timing and Control**

### **Control Unit Overview**
The control unit generates control signals to direct operations across the CPU and memory.

### **Control Signals**:
Control signals coordinate the operation of the CPU and are generated by the control unit. These signals manage:
- Data transfer between registers.
- Instruction execution in the ALU.
- Timing for memory and I/O access.

### **Two Types of Control**
1. **Hardwired Control**:
   - Uses combinational logic circuits to produce control signals.
   - Faster but less flexible.
2. **Microprogrammed Control**:
   - Uses a sequence of microinstructions stored in control memory to generate control signals.
   - Easier to modify but slower than hardwired control.

### **Timing and Synchronization**
- **Clock Signals** synchronize operations:
  - **T1**: Fetch the instruction.
  - **T2**: Decode the instruction.
  - **T3**: Execute the instruction.

---

## **5.5 Instruction Cycle**

The instruction cycle describes the sequence of steps performed by the CPU to execute an instruction.

### **Phases**
1. **Fetch Phase**:
   - Retrieve the next instruction from memory.
   - Example:
     - `MAR ← PC` (Load the address of the instruction).
     - `MDR ← Memory[MAR]` (Read the instruction).
     - `IR ← MDR` (Load the instruction into IR).
     - `PC ← PC + 1` (Increment the program counter).


2. **Decode Phase**:
   - Decode the opcode and determine the addressing mode.
   - Example: Decode whether it’s `ADD`, `JUMP`, etc.

3. **Execute Phase**:
   - Perform the operation specified by the instruction.
   - Example:
     - For `ADD X`:
       - `MAR ← Address in IR`.
       - `MDR ← Memory[MAR]`.
       - `AC ← AC + MDR`.

4. **Interrupt Handling** (if applicable):
   - Save the current state and service the interrupt.
   - If an interrupt is pending, save the CPU state and execute the interrupt service routine (ISR).

---

## **5.6 Input-Output and Interrupts**

### **I/O Techniques**
1. **Programmed I/O**:
   - CPU directly manages data transfer.
   - Inefficient as the CPU waits for I/O completion.

2. **Interrupt-Driven I/O**:
   - Devices notify the CPU with an interrupt when they’re ready.
   - The CPU performs other tasks while waiting.

3. **Direct Memory Access (DMA)**:
   - A DMA controller handles data transfer between memory and I/O devices, bypassing the CPU.

### **Interrupts**
- **Purpose**: Efficiently handle asynchronous events.
- **Process**:
  1. Save CPU state.
  2. Execute Interrupt Service Routine (ISR).
  3. Restore CPU state and continue.

---

## **5.7 Basic Computer Design**

### **Basic Components**
1. **Registers**:
   - PC, AC, DR, IR, TR.
2. **Memory**:
   - Stores instructions and data.
3. **ALU**:
   - Performs arithmetic and logic operations.
4. **Control Logic**:
   - Generates signals for each microoperation.

### **Instruction Set**
- Contains basic operations like `LOAD`, `STORE`, `ADD`, and `JUMP`.

---

## **5.8 Control Unit Design**

### **Hardwired Control**:
- Uses sequential logic circuits to generate control signals.
- Pros: Fast.
- Cons: Inflexible.

### **Microprogrammed Control**:
- Control signals are stored as microinstructions in control memory.
- Pros: Flexible and easier to modify.
- Cons: Slower than hardwired control.


---

## **Example of Instruction Execution**

### Instruction: `ADD X`
1. **Fetch**:
   - Load the instruction into IR.

   - `MAR ← PC`.
   - `MDR ← Memory[MAR]`.
   - `IR ← MDR`.
   - `PC ← PC + 1`.

2. **Decode**:
   - Decode the opcode and identify `ADD` operation.

3. **Execute**:
   - Fetch the operand from memory.

   - `MAR ← Address in IR`.
   - `MDR ← Memory[MAR]`.
   - `AC ← AC + MDR`.

---

## **Summary of Key Takeaways**

1. **Registers** are central to the CPU’s operation.
2. **Instruction Cycle** defines the systematic execution of instructions.
3. **Control Unit** ensures operations are executed accurately.
4. **Interrupts** improve efficiency by allowing asynchronous I/O operations.
5. **Basic Design** concepts provide a foundation for understanding advanced architectures.

